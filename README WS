# Guide rapide – ft_transcendence WebSocket

## 0. Installer les dépendances

```sh
cd frontend && npm install
cd ../backend && npm install
```

## 1. Structure du projet

- `dist/` → fichiers .js générés à partir des fichiers TypeScript (.ts)

## 2. Schéma du fonctionnement WebSocket

```
[ Navigateur (frontend) ]
      <->  (WebSocket)
[ Serveur Node.js (backend) ]
```

Le WebSocket permet une communication bidirectionnelle : le navigateur peut envoyer des messages au serveur, et le serveur peut répondre ou envoyer des messages à tout moment, sans recharger la page.

---

## 3. Compilation & Lancement

**En local (hors Docker)**
```sh
cd frontend && npx tsc
cd ../backend && npx tsc && node dist/server.js
```

**Avec Docker (recommandé)**
```sh
make re
```
- Le backend recompile automatiquement le TypeScript à chaque démarrage du conteneur.
- Accès : http://localhost:3000 (frontend), http://localhost:8080 (backend)

---

## 4. Lancer le frontend

- Installer l'extension Live Server sur VS Code.
- Ouvrir `index.html` → clic droit → Open with Live Server.

---

## 5. Tester le WebSocket

Dans la console du navigateur (F12) :
```js
sendPing(); // Réponse du serveur attendue
sendMessage('move', { y: 120 }); // Message valide
sendMessage('move', { y: "abc" }); // Message invalide, ignoré côté serveur
```

---

## 6. Tester les rooms (multijoueur)

- Ouvre plusieurs navigateurs ou onglets pour simuler plusieurs clients.
- Pour rejoindre/créer une room de la taille souhaitée :

```js
joinOrCreateRoom(2); // Room 1v1
joinOrCreateRoom(4); // Room 2v2
```
- La fonction `joinOrCreateRoom(maxPlayers)` est générique et gère tout (création, join, anti-zap).
- La room rejointe/créée s'affiche dans la console.

---

## 7. Fonctionnement des rooms & sécurité anti-zap

- À la connexion, chaque client rejoint automatiquement une room adaptée.
- Tous les users d'une même room reçoivent les updates des autres.
- **Anti-zap** : si tu es déjà dans une room non pleine d'un certain type (ex : 1v1), tu ne peux PAS zapper vers une autre room du même type tant qu'elle n'est pas pleine. Tu peux cependant zapper vers une room d'un autre type (ex : 2v2 ↔ 1v1).
- Un seul room à la fois par client.
- Quand un client se déconnecte, il est retiré de sa room.

---

## 8. Problèmes fréquents

- Erreur "Cannot find module dist/server.js" → Compile d'abord avec npx tsc dans le backend ou relance le conteneur.
- Pas de réponse WebSocket → Vérifie que le backend est bien lancé et que le frontend est ouvert avec Live Server.

---

## 9. API et exemples utiles

- **Rejoindre/créer une room** :
```js
joinOrCreateRoom(maxPlayers); // maxPlayers = 2 (1v1), 4 (2v2), etc.
```
- **Envoyer un message à tous les membres d'une room (backend)** :
```ts
io.to('roomName').emit('event', data);
```
- **Envoyer un message structuré (frontend)** :
```js
sendMessage('move', { y: 120 });
sendMessage('score', { left: 1, right: 2 });
```

---

## 10. Résumé technique

- Chaque client connecté reçoit un `socket.id` unique.
- Les rooms sont des groupes logiques : un nom, une capacité (`maxPlayers`), une liste de sockets.
- La logique anti-zap est gérée côté backend : impossible de zapper entre rooms non pleines du même type, mais possible entre types différents.
- La fonction frontend `joinOrCreateRoom(maxPlayers)` est la seule à utiliser pour tester toutes les tailles de rooms.

---

**Pour toute question ou bug, ping qordoux.**
